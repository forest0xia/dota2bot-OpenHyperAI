// matchups.ts
import fs from "node:fs";
import path from "node:path";
import puppeteer, { Browser } from "puppeteer";
import * as cheerio from "cheerio";
import { hero_name_table } from "./names";

const USER_AGENT = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36";

type Counters = Record<string, number>;

const visibleToInternal: Record<string, string> = Object.fromEntries(
    Object.entries(hero_name_table).map(([internal, data]) => [data.visibleName.toLowerCase(), internal])
);

async function withBrowser<T>(fn: (browser: Browser) => Promise<T>): Promise<T> {
    const browser = await puppeteer.launch({
        headless: true, // cross-version safe
        args: ["--no-sandbox", "--disable-gpu"],
    });
    try {
        return await fn(browser);
    } finally {
        await browser.close();
    }
}

async function fetchHtml(url: string, browser: Browser): Promise<string> {
    const page = await browser.newPage();
    await page.setUserAgent(USER_AGENT);
    await page.goto(url, { waitUntil: "domcontentloaded" });
    try {
        // Dotabuff pages render a sortable table we parse
        await page.waitForSelector("table.sortable", { timeout: 1000 });
    } catch {
        // ignore if it never appearsâ€”parsers already handle "no table" gracefully
    }
    const html = await page.content();
    await page.close();
    return html;
}

function parseCounterTable(html: string): Counters | null {
    const $ = cheerio.load(html);
    const table = $("table.sortable").first();
    if (!table.length) return null;

    const counters: Counters = {};
    const rows = table.find("tr").toArray().slice(1);

    for (const row of rows) {
        const cols = $(row).find("td");
        if (cols.length >= 3) {
            const heroVisible = $(cols[1]).text().trim().toLowerCase();
            const advantageTxt = $(cols[2]).text().trim().replace("%", "");
            const advantage = Number(advantageTxt);
            if (!Number.isFinite(advantage)) continue;

            const internal = visibleToInternal[heroVisible];
            if (internal) counters[internal] = advantage;
        }
    }

    return counters;
}

async function getHeroCounters(heroUrlName: string, browser: Browser): Promise<Counters | null> {
    // past 12 months
    const url = `https://www.dotabuff.com/heroes/${heroUrlName}/counters?date=year`;
    const html = await fetchHtml(url, browser);
    return parseCounterTable(html);
}

async function main() {
    const matchupDict: Record<string, Counters> = {};

    await withBrowser(async browser => {
        for (const [internalName, data] of Object.entries(hero_name_table)) {
            console.log(`Fetching counters for ${internalName}...`);
            try {
                const counters = await getHeroCounters(data.urlName, browser);
                if (counters) {
                    matchupDict[internalName] = counters;
                } else {
                    console.warn(`No counters found for ${internalName}.`);
                }
            } catch (e) {
                console.error(`Error on ${internalName}:`, e);
            }
        }
    });

    // Write Lua (mirrors Python)
    //   const outPath = path.resolve(process.cwd(), "matchups_data.lua");
    const outPath = path.resolve(__dirname, "../../bots/FretBots/matchups_data.lua");

    const lines: string[] = [];
    lines.push("-----");
    lines.push("-- This file is generated by typescript/post-process/matchups.ts");
    lines.push("-----\n");
    lines.push("local heroList = {");
    for (const [hero, counterDict] of Object.entries(matchupDict)) {
        lines.push(`    ['${hero}'] = {`);
        for (const [counterHero, advantage] of Object.entries(counterDict)) {
            lines.push(`        ['${counterHero}'] = ${advantage},`);
        }
        lines.push("    },");
    }
    lines.push("}\n\nreturn heroList\n");

    fs.writeFileSync(outPath, lines.join("\n"), "utf-8");
    console.log("matchups_data.lua has been generated!");
}

if (require.main === module) {
    main().catch(e => {
        console.error("Fatal error:", e);
        process.exit(1);
    });
}
